# TODO LIST:
# arr[1] = 5 ??
# a.test = 2 ??
# ClassDef / FunctionDef?
# lambda functions?

    stmt = FunctionDef                                                                              = + (ignore)
          | AsyncFunctionDef                                                                        = + (ignore)
          | ClassDef                                                                                = + (ignore)
          | Return(expr? value)                                                                     = -

          | Delete(expr* targets)                                                                   = + (wont do)
          | Assign(expr* targets, expr value, string? type_comment)                                 = +  (w/o attr, arr & slicing)
                                                                                                    targets*: a = b = x

          | AugAssign(expr target, operator op, expr value)                                         = + (w/o attr, arr & slicing)
          -- 'simple' indicates that we annotate simple name without parens
          | AnnAssign(expr target, expr annotation, expr? value, int simple)                        = a: int (= 3)+ (no ann)

          -- use 'orelse' because else is a keyword in target languages
          | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)             = +
          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)        = + (sync)
          | While(expr test, stmt* body, stmt* orelse)                                              = + (wont do)
          | If(expr test, stmt* body, stmt* orelse)                                                 = +- [NO CONTEXT]
          | With(withitem* items, stmt* body, string? type_comment)                                 = + (wont do)
          | AsyncWith(withitem* items, stmt* body, string? type_comment)                            = + (sync)

          | Raise(expr? exc, expr? cause)                                                           = + (wont do)
          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)                 = + (wont do)
          | Assert(expr test, expr? msg)                                                            = + (wont do)

          | Import(alias* names)                                                                    = ?
          | ImportFrom(identifier? module, alias* names, int? level)                                = ?

          | Global(identifier* names)                                                               = + (wont do)
          | Nonlocal(identifier* names)                                                             = + (wont do)
          | Expr(expr value)                                                                        = +-
          | Pass                                                                                    = +
          | Break                                                                                   = + (wont do)
          | Continue                                                                                = + (wont do)

          -- XXX Jython will be different
          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

expr = BoolOp(boolop op, expr* values)                                                              = True and False +
         | NamedExpr(expr target, expr value)                                                       = ??? (what's this???)
         | BinOp(expr left, operator op, expr right)                                                = 1 & 2 +
         | UnaryOp(unaryop op, expr operand)                                                        = not 1 +
         | Lambda(arguments args, expr body)                                                        = + (wont do)
         | IfExp(expr test, expr body, expr orelse)                                                 = ?
         | Dict(expr* keys, expr* values)                                                           = {1: 2} +
         | Set(expr* elts)                                                                          = {1, 2} +
         | ListComp(expr elt, comprehension* generators)                                            = + (wont do)
         | SetComp(expr elt, comprehension* generators)                                             = + (wont do)
         | DictComp(expr key, expr value, comprehension* generators)                                = + (wont do)
         | GeneratorExp(expr elt, comprehension* generators)                                        = + (wont do)
         -- the grammar constrains where yield expressions can occur
         | Await(expr value)                                                                        = + (ignore)
         | Yield(expr? value)                                                                       = + (wont do)
         | YieldFrom(expr value)                                                                    = + (wont do)
         -- need sequences for compare to distinguish between
         -- x < 4 < 3 and (x < 4) < 3
         | Compare(expr left, cmpop* ops, expr* comparators)                                        = 1 < 2 < 3 < 4 +
         | Call(expr func, expr* args, keyword* keywords)                                           = test() +?
         | FormattedValue(expr value, int? conversion, expr? format_spec)                           = + (w/o conversion)
         | JoinedStr(expr* values)                                                                  = f'{a} str' +
         | Constant(constant value, string? kind)                                                   = +

         -- the following expression can appear in assignment context
         | Attribute(expr value, identifier attr, expr_context ctx)                                 = a.f -
         | Subscript(expr value, slice slice, expr_context ctx)                                     = a[0] -
         | Starred(expr value, expr_context ctx)                                                    = c, *a, b +
         | Name(identifier id, expr_context ctx)                                                    = a +
         | List(expr* elts, expr_context ctx)                                                       = [a, b] +
         | Tuple(expr* elts, expr_context ctx)                                                      = a, b +

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)
